agent Follower {
    module EIS ei;
    module Console C;
    module Routing routing;
    module System S;
    
    types follower {
        formula task(string);
        formula waitingForTask(boolean);
        formula leader(string);
        formula requestTask();
        formula assignTask(long, long);
        formula noTask();
        formula taskComplete(long, long);
        formula targetX(long);
        formula targetY(long);
        formula lastX(long);
        formula lastY(long);
        formula stuckCount(int);
        formula escapeDir(int);
    }
    
    rule +!main([string vacbot, string leaderName]) {
        ei.join("hw");
        ei.link(vacbot);
        +leader(leaderName);
        +waitingForTask(false);
        +stuckCount(0);
        +escapeDir(0);
        C.println("Follower " + vacbot + " activated, leader: " + leaderName);
    }
    
    rule +$ei.event(location(long X, long Y)) {
        !checkStuck(X, Y);
        !update();
        
        if (targetX(long tX) & targetY(long tY) & X == tX & Y == tY) {
            !cleanTask(tX, tY);
        } else {
            !doTask();
        }
    }
    
    rule +!checkStuck(long X, long Y) : lastX(long lX) & lastY(long lY) & stuckCount(int sc) {
        if (lX == X & lY == Y) {
            int newSc = sc + 1;
            -+stuckCount(newSc);
            if (newSc > 2) {
                C.println("Follower: Stuck detected! Taking evasive action");
                !evasiveMove();
                -+stuckCount(0);
            }
        } else {
            -+stuckCount(0);
            -+lastX(X);
            -+lastY(Y);
        }
    }
    
    rule +!checkStuck(long X, long Y) {
        +lastX(X);
        +lastY(Y);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 0 & ei.square("back", "empty") {
        ei.move("back");
        -+escapeDir(1);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 0 & ei.square("back", "dust") {
        ei.move("back");
        -+escapeDir(1);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 1 & ei.square("right", "empty") {
        ei.move("right");
        -+escapeDir(2);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 1 & ei.square("right", "dust") {
        ei.move("right");
        -+escapeDir(2);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 2 & ei.square("left", "empty") {
        ei.move("left");
        -+escapeDir(3);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 2 & ei.square("left", "dust") {
        ei.move("left");
        -+escapeDir(3);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 3 & ei.square("forward", "empty") {
        ei.move("forward");
        -+escapeDir(0);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 3 & ei.square("forward", "dust") {
        ei.move("forward");
        -+escapeDir(0);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("back", "empty") {
        ei.move("back");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("back", "dust") {
        ei.move("back");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("right", "empty") {
        ei.move("right");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("right", "dust") {
        ei.move("right");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("left", "empty") {
        ei.move("left");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("left", "dust") {
        ei.move("left");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("forward", "empty") {
        ei.move("forward");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("forward", "dust") {
        ei.move("forward");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) {
        ei.move("back");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!update() : ei.location(long X, long Y) & ei.direction(string D) {
        foreach(ei.square(string loc, "obstacle") & 
                ~routing.obstacle(X, Y, D, loc)) {
            routing.recordObstacle(X, Y, D, loc);
        }
        long maxX = routing.maxX() + 1;
        long maxY = routing.maxY() + 1;
        routing.updateBoundary(maxX, maxY);
    }
    
    rule +!askForTask() : leader(string leaderName) & waitingForTask(false) {
        -+waitingForTask(true);
        send(request, leaderName, requestTask());
    }
    
    rule +!askForTask() {
    }
    
    rule @message(inform, string sender, assignTask(long X, long Y)) {
        -+waitingForTask(false);
        +targetX(X);
        +targetY(Y);
    }
    
    rule @message(inform, string sender, noTask()) {
        -+waitingForTask(false);
    }
    
    rule +!cleanTask(long taskX, long taskY) : ei.square("here", "dust") & leader(string leaderName) {
        ei.clean();
        -targetX(taskX);
        -targetY(taskY);
        send(inform, leaderName, taskComplete(taskX, taskY));
        !move();
    }
    
    rule +!cleanTask(long taskX, long taskY) : leader(string leaderName) {
        -targetX(taskX);
        -targetY(taskY);
        send(inform, leaderName, taskComplete(taskX, taskY));
        !move();
    }
    
    rule +!doTask() : ei.square("here", "dust") & ei.location(long X, long Y) & leader(string leaderName) {
        ei.clean();
        send(inform, leaderName, taskComplete(X, Y));
        if (targetX(long tX) & targetY(long tY) & tX == X & tY == Y) {
            -targetX(tX);
            -targetY(tY);
        }
        !move();
    }
    
    rule +!doTask() : ~targetX(long tX) {
        !askForTask();
        !move();
    }
    
    rule +!doTask() {
        !move();
    }
    
    rule +!move() : ei.square("forward", "dust") {
        ei.move("forward");
    }
    
    rule +!move() : ei.square("left", "dust") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("right", "dust") {
        ei.move("right");
    }
    
    rule +!move() : ei.square("forward", "vac") & ei.square("left", "empty") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("forward", "vac") & ei.square("left", "dust") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("forward", "vac") & ei.square("right", "empty") {
        ei.move("right");
    }
    
    rule +!move() : ei.square("forward", "vac") & ei.square("right", "dust") {
        ei.move("right");
    }
    
    rule +!move() : ei.square("forward", "vac") {
        ei.move("back");
    }
    
    rule +!move() : ei.square("forward", "obstacle") & ei.square("left", "obstacle") & 
                    ei.square("right", "obstacle") {
        ei.move("back");
    }
    
    rule +!move() : ei.square("forward", "obstacle") & ei.square("left", "obstacle") {
        ei.move("right");
    }
    
    rule +!move() : ei.square("forward", "obstacle") & ei.square("right", "obstacle") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("forward", "obstacle") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("forward", "empty") {
        ei.move("forward");
    }
    
    rule +!move() : ei.square("left", "empty") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("right", "empty") {
        ei.move("right");
    }
    
    rule +!move() {
        ei.move("back");
    }
}