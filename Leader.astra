agent Leader {
    module EIS ei;
    module Console C;
    module Routing routing;
    module System S;
    
    types leader {
        formula task(string);
        formula dustLocation(long, long);
        formula assignedTask(string, long, long);
        formula requestTask();
        formula assignTask(long, long);
        formula noTask();
        formula taskComplete(long, long);
        formula taskUnreachable(long, long);
        formula lastX(long);
        formula lastY(long);
        formula stuckCount(int);
        formula escapeDir(int);
    }
    
    rule +!main([string vacbot]) {
        ei.join("hw");
        ei.link(vacbot);
        +stuckCount(0);
        +escapeDir(0);
        C.println("Leader " + vacbot + " activated");
    }
    
    rule +$ei.event(location(long X, long Y)) {
        !checkStuck(X, Y);
        !update();
        !doTask();
    }
    
    rule +!checkStuck(long X, long Y) : lastX(long lX) & lastY(long lY) & stuckCount(int sc) {
        if (lX == X & lY == Y) {
            int newSc = sc + 1;
            -+stuckCount(newSc);
            if (newSc > 2) {
                C.println("Leader: Stuck detected! Taking evasive action");
                !evasiveMove();
                -+stuckCount(0);
            }
        } else {
            -+stuckCount(0);
            -+lastX(X);
            -+lastY(Y);
        }
    }
    
    rule +!checkStuck(long X, long Y) {
        +lastX(X);
        +lastY(Y);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 0 & ei.square("back", "empty") {
        ei.move("back");
        -+escapeDir(1);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 0 & ei.square("back", "dust") {
        ei.move("back");
        -+escapeDir(1);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 1 & ei.square("left", "empty") {
        ei.move("left");
        -+escapeDir(2);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 1 & ei.square("left", "dust") {
        ei.move("left");
        -+escapeDir(2);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 2 & ei.square("right", "empty") {
        ei.move("right");
        -+escapeDir(3);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 2 & ei.square("right", "dust") {
        ei.move("right");
        -+escapeDir(3);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 3 & ei.square("forward", "empty") {
        ei.move("forward");
        -+escapeDir(0);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ed == 3 & ei.square("forward", "dust") {
        ei.move("forward");
        -+escapeDir(0);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("back", "empty") {
        ei.move("back");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("back", "dust") {
        ei.move("back");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("left", "empty") {
        ei.move("left");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("left", "dust") {
        ei.move("left");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("right", "empty") {
        ei.move("right");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("right", "dust") {
        ei.move("right");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("forward", "empty") {
        ei.move("forward");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) & ei.square("forward", "dust") {
        ei.move("forward");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!evasiveMove() : escapeDir(int ed) {
        ei.move("back");
        int newEd = ed + 1;
        if (newEd > 3) {
            newEd = 0;
        }
        -+escapeDir(newEd);
    }
    
    rule +!update() : ei.location(long X, long Y) & ei.direction(string D) {
        foreach(ei.square(string loc, "obstacle") & 
                ~routing.obstacle(X, Y, D, loc)) {
            routing.recordObstacle(X, Y, D, loc);
        }
        long maxX = routing.maxX() + 1;
        long maxY = routing.maxY() + 1;
        routing.updateBoundary(maxX, maxY);
        !checkForDust();
    }
    
    rule +!checkForDust() : ei.location(long X, long Y) & ei.direction(string D) {
        foreach(ei.square(string loc, "dust")) {
            !recordDustLocation(X, Y, D, loc);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, string D, "here") {
        if (~dustLocation(X, Y)) {
            +dustLocation(X, Y);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "north", "forward") {
        long newY = Y - 1;
        if (~dustLocation(X, newY)) {
            +dustLocation(X, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "south", "forward") {
        long newY = Y + 1;
        if (~dustLocation(X, newY)) {
            +dustLocation(X, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "east", "forward") {
        long newX = X + 1;
        if (~dustLocation(newX, Y)) {
            +dustLocation(newX, Y);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "west", "forward") {
        long newX = X - 1;
        if (~dustLocation(newX, Y)) {
            +dustLocation(newX, Y);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "north", "left") {
        long newX = X - 1;
        if (~dustLocation(newX, Y)) {
            +dustLocation(newX, Y);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "south", "left") {
        long newX = X + 1;
        if (~dustLocation(newX, Y)) {
            +dustLocation(newX, Y);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "east", "left") {
        long newY = Y - 1;
        if (~dustLocation(X, newY)) {
            +dustLocation(X, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "west", "left") {
        long newY = Y + 1;
        if (~dustLocation(X, newY)) {
            +dustLocation(X, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "north", "right") {
        long newX = X + 1;
        if (~dustLocation(newX, Y)) {
            +dustLocation(newX, Y);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "south", "right") {
        long newX = X - 1;
        if (~dustLocation(newX, Y)) {
            +dustLocation(newX, Y);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "east", "right") {
        long newY = Y + 1;
        if (~dustLocation(X, newY)) {
            +dustLocation(X, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "west", "right") {
        long newY = Y - 1;
        if (~dustLocation(X, newY)) {
            +dustLocation(X, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "north", "forwardLeft") {
        long newX = X - 1;
        long newY = Y - 1;
        if (~dustLocation(newX, newY)) {
            +dustLocation(newX, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "north", "forwardRight") {
        long newX = X + 1;
        long newY = Y - 1;
        if (~dustLocation(newX, newY)) {
            +dustLocation(newX, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "south", "forwardLeft") {
        long newX = X + 1;
        long newY = Y + 1;
        if (~dustLocation(newX, newY)) {
            +dustLocation(newX, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "south", "forwardRight") {
        long newX = X - 1;
        long newY = Y + 1;
        if (~dustLocation(newX, newY)) {
            +dustLocation(newX, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "east", "forwardLeft") {
        long newX = X + 1;
        long newY = Y - 1;
        if (~dustLocation(newX, newY)) {
            +dustLocation(newX, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "east", "forwardRight") {
        long newX = X + 1;
        long newY = Y + 1;
        if (~dustLocation(newX, newY)) {
            +dustLocation(newX, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "west", "forwardLeft") {
        long newX = X - 1;
        long newY = Y + 1;
        if (~dustLocation(newX, newY)) {
            +dustLocation(newX, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, "west", "forwardRight") {
        long newX = X - 1;
        long newY = Y - 1;
        if (~dustLocation(newX, newY)) {
            +dustLocation(newX, newY);
        }
    }
    
    rule +!recordDustLocation(long X, long Y, string D, string loc) {
    }
    
    rule @message(request, string follower, requestTask()) : 
         dustLocation(long dustX, long dustY) & ~assignedTask(string wrkr, dustX, dustY) {
        +assignedTask(follower, dustX, dustY);
        send(inform, follower, assignTask(dustX, dustY));
    }
    
    rule @message(request, string follower, requestTask()) {
        send(inform, follower, noTask());
    }
    
    rule @message(inform, string follower, taskComplete(long X, long Y)) {
        -dustLocation(X, Y);
        if (assignedTask(follower, X, Y)) {
            -assignedTask(follower, X, Y);
        }
    }
    
    rule @message(inform, string follower, taskUnreachable(long X, long Y)) {
        if (assignedTask(follower, X, Y)) {
            -assignedTask(follower, X, Y);
        }
    }
    
    rule +!doTask() : ei.square("here", "dust") & ei.location(long X, long Y) {
        ei.clean();
        -dustLocation(X, Y);
        !move();
    }
    
    rule +!doTask() {
        !move();
    }
    
    rule +!move() : ei.square("forward", "dust") {
        ei.move("forward");
    }
    
    rule +!move() : ei.square("left", "dust") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("right", "dust") {
        ei.move("right");
    }
    
    rule +!move() : ei.square("forward", "vac") & ei.square("right", "empty") {
        ei.move("right");
    }
    
    rule +!move() : ei.square("forward", "vac") & ei.square("right", "dust") {
        ei.move("right");
    }
    
    rule +!move() : ei.square("forward", "vac") & ei.square("left", "empty") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("forward", "vac") & ei.square("left", "dust") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("forward", "vac") {
        ei.move("back");
    }
    
    rule +!move() : ei.square("forward", "obstacle") & ei.square("left", "obstacle") & 
                    ei.square("right", "obstacle") {
        ei.move("back");
    }
    
    rule +!move() : ei.square("forward", "obstacle") & ei.square("left", "obstacle") {
        ei.move("right");
    }
    
    rule +!move() : ei.square("forward", "obstacle") & ei.square("right", "obstacle") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("forward", "obstacle") {
        ei.move("right");
    }
    
    rule +!move() : ei.square("forward", "empty") {
        ei.move("forward");
    }
    
    rule +!move() : ei.square("left", "empty") {
        ei.move("left");
    }
    
    rule +!move() : ei.square("right", "empty") {
        ei.move("right");
    }
    
    rule +!move() {
        ei.move("back");
    }
}